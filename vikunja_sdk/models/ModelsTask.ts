/* tslint:disable */
/* eslint-disable */
/**
 * Vikunja API
 * # Pagination Every endpoint capable of pagination will return two headers: * `x-pagination-total-pages`: The total number of available pages for this request * `x-pagination-result-count`: The number of items returned for this request. # Rights All endpoints which return a single item (project, task, etc.) - no array - will also return a `x-max-right` header with the max right the user has on this item as an int where `0` is `Read Only`, `1` is `Read & Write` and `2` is `Admin`. This can be used to show or hide ui elements based on the rights the user has. # Errors All errors have an error code and a human-readable error message in addition to the http status code. You should always check for the status code in the response, not only the http status code. Due to limitations in the swagger library we\'re using for this document, only one error per http status code is documented here. Make sure to check the [error docs](https://vikunja.io/docs/errors/) in Vikunja\'s documentation for a full list of available error codes. # Authorization **JWT-Auth:** Main authorization method, used for most of the requests. Needs `Authorization: Bearer <jwt-token>`-header to authenticate successfully.  **API Token:** You can create scoped API tokens for your user and use the token to make authenticated requests in the context of that user. The token must be provided via an `Authorization: Bearer <token>` header, similar to jwt auth. See the documentation for the `api` group to manage token creation and revocation.  **BasicAuth:** Only used when requesting tasks via CalDAV. <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: v0.23.0-879-f2ac9c2cca
 * Contact: hello@vikunja.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { ModelsTaskAttachment } from './ModelsTaskAttachment';
import {
    ModelsTaskAttachmentFromJSON,
    ModelsTaskAttachmentFromJSONTyped,
    ModelsTaskAttachmentToJSON,
} from './ModelsTaskAttachment';
import type { ModelsLabel } from './ModelsLabel';
import {
    ModelsLabelFromJSON,
    ModelsLabelFromJSONTyped,
    ModelsLabelToJSON,
} from './ModelsLabel';
import type { ModelsSubscription } from './ModelsSubscription';
import {
    ModelsSubscriptionFromJSON,
    ModelsSubscriptionFromJSONTyped,
    ModelsSubscriptionToJSON,
} from './ModelsSubscription';
import type { ModelsTaskRepeatMode } from './ModelsTaskRepeatMode';
import {
    ModelsTaskRepeatModeFromJSON,
    ModelsTaskRepeatModeFromJSONTyped,
    ModelsTaskRepeatModeToJSON,
} from './ModelsTaskRepeatMode';
import type { ModelsTaskReminder } from './ModelsTaskReminder';
import {
    ModelsTaskReminderFromJSON,
    ModelsTaskReminderFromJSONTyped,
    ModelsTaskReminderToJSON,
} from './ModelsTaskReminder';
import type { UserUser } from './UserUser';
import {
    UserUserFromJSON,
    UserUserFromJSONTyped,
    UserUserToJSON,
} from './UserUser';

/**
 * 
 * @export
 * @interface ModelsTask
 */
export interface ModelsTask {
    /**
     * An array of users who are assigned to this task
     * @type {Array<UserUser>}
     * @memberof ModelsTask
     */
    assignees?: Array<UserUser>;
    /**
     * All attachments this task has
     * @type {Array<ModelsTaskAttachment>}
     * @memberof ModelsTask
     */
    attachments?: Array<ModelsTaskAttachment>;
    /**
     * The bucket id. Will only be populated when the task is accessed via a view with buckets.
     * Can be used to move a task between buckets. In that case, the new bucket must be in the same view as the old one.
     * @type {number}
     * @memberof ModelsTask
     */
    bucketId?: number;
    /**
     * If this task has a cover image, the field will return the id of the attachment that is the cover image.
     * @type {number}
     * @memberof ModelsTask
     */
    coverImageAttachmentId?: number;
    /**
     * A timestamp when this task was created. You cannot change this value.
     * @type {string}
     * @memberof ModelsTask
     */
    created?: string;
    /**
     * The user who initially created the task.
     * @type {UserUser}
     * @memberof ModelsTask
     */
    createdBy?: UserUser;
    /**
     * The task description.
     * @type {string}
     * @memberof ModelsTask
     */
    description?: string;
    /**
     * Whether a task is done or not.
     * @type {boolean}
     * @memberof ModelsTask
     */
    done?: boolean;
    /**
     * The time when a task was marked as done.
     * @type {string}
     * @memberof ModelsTask
     */
    doneAt?: string;
    /**
     * The time when the task is due.
     * @type {string}
     * @memberof ModelsTask
     */
    dueDate?: string;
    /**
     * When this task ends.
     * @type {string}
     * @memberof ModelsTask
     */
    endDate?: string;
    /**
     * The task color in hex
     * @type {string}
     * @memberof ModelsTask
     */
    hexColor?: string;
    /**
     * The unique, numeric id of this task.
     * @type {number}
     * @memberof ModelsTask
     */
    id?: number;
    /**
     * The task identifier, based on the project identifier and the task's index
     * @type {string}
     * @memberof ModelsTask
     */
    identifier?: string;
    /**
     * The task index, calculated per project
     * @type {number}
     * @memberof ModelsTask
     */
    index?: number;
    /**
     * True if a task is a favorite task. Favorite tasks show up in a separate "Important" project. This value depends on the user making the call to the api.
     * @type {boolean}
     * @memberof ModelsTask
     */
    isFavorite?: boolean;
    /**
     * An array of labels which are associated with this task.
     * @type {Array<ModelsLabel>}
     * @memberof ModelsTask
     */
    labels?: Array<ModelsLabel>;
    /**
     * Determines how far a task is left from being done
     * @type {number}
     * @memberof ModelsTask
     */
    percentDone?: number;
    /**
     * The position of the task - any task project can be sorted as usual by this parameter.
     * When accessing tasks via views with buckets, this is primarily used to sort them based on a range.
     * Positions are always saved per view. They will automatically be set if you request the tasks through a view
     * endpoint, otherwise they will always be 0. To update them, take a look at the Task Position endpoint.
     * @type {number}
     * @memberof ModelsTask
     */
    position?: number;
    /**
     * The task priority. Can be anything you want, it is possible to sort by this later.
     * @type {number}
     * @memberof ModelsTask
     */
    priority?: number;
    /**
     * The project this task belongs to.
     * @type {number}
     * @memberof ModelsTask
     */
    projectId?: number;
    /**
     * Reactions on that task.
     * @type {{ [key: string]: Array<UserUser>; }}
     * @memberof ModelsTask
     */
    reactions?: { [key: string]: Array<UserUser>; };
    /**
     * All related tasks, grouped by their relation kind
     * @type {{ [key: string]: Array<ModelsTask>; }}
     * @memberof ModelsTask
     */
    relatedTasks?: { [key: string]: Array<ModelsTask>; };
    /**
     * An array of reminders that are associated with this task.
     * @type {Array<ModelsTaskReminder>}
     * @memberof ModelsTask
     */
    reminders?: Array<ModelsTaskReminder>;
    /**
     * An amount in seconds this task repeats itself. If this is set, when marking the task as done, it will mark itself as "undone" and then increase all remindes and the due date by its amount.
     * @type {number}
     * @memberof ModelsTask
     */
    repeatAfter?: number;
    /**
     * Can have three possible values which will trigger when the task is marked as done: 0 = repeats after the amount specified in repeat_after, 1 = repeats all dates each months (ignoring repeat_after), 3 = repeats from the current date rather than the last set date.
     * @type {ModelsTaskRepeatMode}
     * @memberof ModelsTask
     */
    repeatMode?: ModelsTaskRepeatMode;
    /**
     * When this task starts.
     * @type {string}
     * @memberof ModelsTask
     */
    startDate?: string;
    /**
     * The subscription status for the user reading this task. You can only read this property, use the subscription endpoints to modify it.
     * Will only returned when retrieving one task.
     * @type {ModelsSubscription}
     * @memberof ModelsTask
     */
    subscription?: ModelsSubscription;
    /**
     * The task text. This is what you'll see in the project.
     * @type {string}
     * @memberof ModelsTask
     */
    title?: string;
    /**
     * A timestamp when this task was last updated. You cannot change this value.
     * @type {string}
     * @memberof ModelsTask
     */
    updated?: string;
}

/**
 * Check if a given object implements the ModelsTask interface.
 */
export function instanceOfModelsTask(value: object): value is ModelsTask {
    return true;
}

export function ModelsTaskFromJSON(json: any): ModelsTask {
    return ModelsTaskFromJSONTyped(json, false);
}

export function ModelsTaskFromJSONTyped(json: any, ignoreDiscriminator: boolean): ModelsTask {
    if (json == null) {
        return json;
    }
    return {
        
        'assignees': json['assignees'] == null ? undefined : ((json['assignees'] as Array<any>).map(UserUserFromJSON)),
        'attachments': json['attachments'] == null ? undefined : ((json['attachments'] as Array<any>).map(ModelsTaskAttachmentFromJSON)),
        'bucketId': json['bucket_id'] == null ? undefined : json['bucket_id'],
        'coverImageAttachmentId': json['cover_image_attachment_id'] == null ? undefined : json['cover_image_attachment_id'],
        'created': json['created'] == null ? undefined : json['created'],
        'createdBy': json['created_by'] == null ? undefined : UserUserFromJSON(json['created_by']),
        'description': json['description'] == null ? undefined : json['description'],
        'done': json['done'] == null ? undefined : json['done'],
        'doneAt': json['done_at'] == null ? undefined : json['done_at'],
        'dueDate': json['due_date'] == null ? undefined : json['due_date'],
        'endDate': json['end_date'] == null ? undefined : json['end_date'],
        'hexColor': json['hex_color'] == null ? undefined : json['hex_color'],
        'id': json['id'] == null ? undefined : json['id'],
        'identifier': json['identifier'] == null ? undefined : json['identifier'],
        'index': json['index'] == null ? undefined : json['index'],
        'isFavorite': json['is_favorite'] == null ? undefined : json['is_favorite'],
        'labels': json['labels'] == null ? undefined : ((json['labels'] as Array<any>).map(ModelsLabelFromJSON)),
        'percentDone': json['percent_done'] == null ? undefined : json['percent_done'],
        'position': json['position'] == null ? undefined : json['position'],
        'priority': json['priority'] == null ? undefined : json['priority'],
        'projectId': json['project_id'] == null ? undefined : json['project_id'],
        'reactions': json['reactions'] == null ? undefined : json['reactions'],
        'relatedTasks': json['related_tasks'] == null ? undefined : json['related_tasks'],
        'reminders': json['reminders'] == null ? undefined : ((json['reminders'] as Array<any>).map(ModelsTaskReminderFromJSON)),
        'repeatAfter': json['repeat_after'] == null ? undefined : json['repeat_after'],
        'repeatMode': json['repeat_mode'] == null ? undefined : ModelsTaskRepeatModeFromJSON(json['repeat_mode']),
        'startDate': json['start_date'] == null ? undefined : json['start_date'],
        'subscription': json['subscription'] == null ? undefined : ModelsSubscriptionFromJSON(json['subscription']),
        'title': json['title'] == null ? undefined : json['title'],
        'updated': json['updated'] == null ? undefined : json['updated'],
    };
}

export function ModelsTaskToJSON(value?: ModelsTask | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'assignees': value['assignees'] == null ? undefined : ((value['assignees'] as Array<any>).map(UserUserToJSON)),
        'attachments': value['attachments'] == null ? undefined : ((value['attachments'] as Array<any>).map(ModelsTaskAttachmentToJSON)),
        'bucket_id': value['bucketId'],
        'cover_image_attachment_id': value['coverImageAttachmentId'],
        'created': value['created'],
        'created_by': UserUserToJSON(value['createdBy']),
        'description': value['description'],
        'done': value['done'],
        'done_at': value['doneAt'],
        'due_date': value['dueDate'],
        'end_date': value['endDate'],
        'hex_color': value['hexColor'],
        'id': value['id'],
        'identifier': value['identifier'],
        'index': value['index'],
        'is_favorite': value['isFavorite'],
        'labels': value['labels'] == null ? undefined : ((value['labels'] as Array<any>).map(ModelsLabelToJSON)),
        'percent_done': value['percentDone'],
        'position': value['position'],
        'priority': value['priority'],
        'project_id': value['projectId'],
        'reactions': value['reactions'],
        'related_tasks': value['relatedTasks'],
        'reminders': value['reminders'] == null ? undefined : ((value['reminders'] as Array<any>).map(ModelsTaskReminderToJSON)),
        'repeat_after': value['repeatAfter'],
        'repeat_mode': ModelsTaskRepeatModeToJSON(value['repeatMode']),
        'start_date': value['startDate'],
        'subscription': ModelsSubscriptionToJSON(value['subscription']),
        'title': value['title'],
        'updated': value['updated'],
    };
}

