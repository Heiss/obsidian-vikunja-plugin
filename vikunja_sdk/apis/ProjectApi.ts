/* tslint:disable */
/* eslint-disable */
/**
 * Vikunja API
 * # Pagination Every endpoint capable of pagination will return two headers: * `x-pagination-total-pages`: The total number of available pages for this request * `x-pagination-result-count`: The number of items returned for this request. # Rights All endpoints which return a single item (project, task, etc.) - no array - will also return a `x-max-right` header with the max right the user has on this item as an int where `0` is `Read Only`, `1` is `Read & Write` and `2` is `Admin`. This can be used to show or hide ui elements based on the rights the user has. # Errors All errors have an error code and a human-readable error message in addition to the http status code. You should always check for the status code in the response, not only the http status code. Due to limitations in the swagger library we\'re using for this document, only one error per http status code is documented here. Make sure to check the [error docs](https://vikunja.io/docs/errors/) in Vikunja\'s documentation for a full list of available error codes. # Authorization **JWT-Auth:** Main authorization method, used for most of the requests. Needs `Authorization: Bearer <jwt-token>`-header to authenticate successfully.  **API Token:** You can create scoped API tokens for your user and use the token to make authenticated requests in the context of that user. The token must be provided via an `Authorization: Bearer <token>` header, similar to jwt auth. See the documentation for the `api` group to manage token creation and revocation.  **BasicAuth:** Only used when requesting tasks via CalDAV. <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: v0.23.0-832-2d358a57cc
 * Contact: hello@vikunja.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BackgroundImage,
  ModelsBucket,
  ModelsMessage,
  ModelsProject,
  ModelsProjectDuplicate,
  ModelsProjectView,
  UserUser,
  WebHTTPError,
} from '../models/index';
import {
    BackgroundImageFromJSON,
    BackgroundImageToJSON,
    ModelsBucketFromJSON,
    ModelsBucketToJSON,
    ModelsMessageFromJSON,
    ModelsMessageToJSON,
    ModelsProjectFromJSON,
    ModelsProjectToJSON,
    ModelsProjectDuplicateFromJSON,
    ModelsProjectDuplicateToJSON,
    ModelsProjectViewFromJSON,
    ModelsProjectViewToJSON,
    UserUserFromJSON,
    UserUserToJSON,
    WebHTTPErrorFromJSON,
    WebHTTPErrorToJSON,
} from '../models/index';

export interface BackgroundsUnsplashImageImageGetRequest {
    image: number;
}

export interface BackgroundsUnsplashImageImageThumbGetRequest {
    image: number;
}

export interface BackgroundsUnsplashSearchGetRequest {
    s?: string;
    p?: number;
}

export interface ProjectsGetRequest {
    page?: number;
    perPage?: number;
    s?: string;
    isArchived?: boolean;
}

export interface ProjectsIdBackgroundDeleteRequest {
    id: number;
}

export interface ProjectsIdBackgroundGetRequest {
    id: number;
}

export interface ProjectsIdBackgroundsUnsplashPostRequest {
    id: number;
    project: BackgroundImage;
}

export interface ProjectsIdBackgroundsUploadPutRequest {
    id: number;
    background: string;
}

export interface ProjectsIdDeleteRequest {
    id: number;
}

export interface ProjectsIdGetRequest {
    id: number;
}

export interface ProjectsIdPostRequest {
    id: number;
    project: ModelsProject;
}

export interface ProjectsIdProjectusersGetRequest {
    id: number;
    s?: string;
}

export interface ProjectsIdViewsViewBucketsGetRequest {
    id: number;
    view: number;
}

export interface ProjectsIdViewsViewBucketsPutRequest {
    id: number;
    view: number;
    bucket: ModelsBucket;
}

export interface ProjectsProjectIDDuplicatePutRequest {
    projectID: number;
    project: ModelsProjectDuplicate;
}

export interface ProjectsProjectIDViewsViewBucketsBucketIDDeleteRequest {
    projectID: number;
    bucketID: number;
    view: number;
}

export interface ProjectsProjectIDViewsViewBucketsBucketIDPostRequest {
    projectID: number;
    bucketID: number;
    view: number;
    bucket: ModelsBucket;
}

export interface ProjectsProjectViewsGetRequest {
    project: number;
}

export interface ProjectsProjectViewsIdDeleteRequest {
    project: number;
    id: number;
}

export interface ProjectsProjectViewsIdGetRequest {
    project: number;
    id: number;
}

export interface ProjectsProjectViewsIdPostRequest {
    project: number;
    id: number;
    view: ModelsProjectView;
}

export interface ProjectsProjectViewsPutRequest {
    project: number;
    view: ModelsProjectView;
}

export interface ProjectsPutRequest {
    project: ModelsProject;
}

/**
 * 
 */
export class ProjectApi extends runtime.BaseAPI {

    /**
     * Get an unsplash image. **Returns json on error.**
     * Get an unsplash image
     */
    async backgroundsUnsplashImageImageGetRaw(requestParameters: BackgroundsUnsplashImageImageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling backgroundsUnsplashImageImageGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/backgrounds/unsplash/image/{image}`.replace(`{${"image"}}`, encodeURIComponent(String(requestParameters['image']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get an unsplash image. **Returns json on error.**
     * Get an unsplash image
     */
    async backgroundsUnsplashImageImageGet(requestParameters: BackgroundsUnsplashImageImageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.backgroundsUnsplashImageImageGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an unsplash thumbnail image. The thumbnail is cropped to a max width of 200px. **Returns json on error.**
     * Get an unsplash thumbnail image
     */
    async backgroundsUnsplashImageImageThumbGetRaw(requestParameters: BackgroundsUnsplashImageImageThumbGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling backgroundsUnsplashImageImageThumbGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/backgrounds/unsplash/image/{image}/thumb`.replace(`{${"image"}}`, encodeURIComponent(String(requestParameters['image']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get an unsplash thumbnail image. The thumbnail is cropped to a max width of 200px. **Returns json on error.**
     * Get an unsplash thumbnail image
     */
    async backgroundsUnsplashImageImageThumbGet(requestParameters: BackgroundsUnsplashImageImageThumbGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.backgroundsUnsplashImageImageThumbGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for a project background from unsplash
     * Search for a background from unsplash
     */
    async backgroundsUnsplashSearchGetRaw(requestParameters: BackgroundsUnsplashSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BackgroundImage>>> {
        const queryParameters: any = {};

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        if (requestParameters['p'] != null) {
            queryParameters['p'] = requestParameters['p'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/backgrounds/unsplash/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BackgroundImageFromJSON));
    }

    /**
     * Search for a project background from unsplash
     * Search for a background from unsplash
     */
    async backgroundsUnsplashSearchGet(requestParameters: BackgroundsUnsplashSearchGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BackgroundImage>> {
        const response = await this.backgroundsUnsplashSearchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all projects a user has access to.
     * Get all projects a user has access to
     */
    async projectsGetRaw(requestParameters: ProjectsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsProject>>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        if (requestParameters['isArchived'] != null) {
            queryParameters['is_archived'] = requestParameters['isArchived'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsProjectFromJSON));
    }

    /**
     * Returns all projects a user has access to.
     * Get all projects a user has access to
     */
    async projectsGet(requestParameters: ProjectsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsProject>> {
        const response = await this.projectsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes a previously set project background, regardless of the project provider used to set the background. It does not throw an error if the project does not have a background.
     * Remove a project background
     */
    async projectsIdBackgroundDeleteRaw(requestParameters: ProjectsIdBackgroundDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProject>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdBackgroundDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/background`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectFromJSON(jsonValue));
    }

    /**
     * Removes a previously set project background, regardless of the project provider used to set the background. It does not throw an error if the project does not have a background.
     * Remove a project background
     */
    async projectsIdBackgroundDelete(requestParameters: ProjectsIdBackgroundDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProject> {
        const response = await this.projectsIdBackgroundDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the project background of a specific project. **Returns json on error.**
     * Get the project background
     */
    async projectsIdBackgroundGetRaw(requestParameters: ProjectsIdBackgroundGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdBackgroundGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/background`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get the project background of a specific project. **Returns json on error.**
     * Get the project background
     */
    async projectsIdBackgroundGet(requestParameters: ProjectsIdBackgroundGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.projectsIdBackgroundGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets a photo from unsplash as project background.
     * Set an unsplash photo as project background
     */
    async projectsIdBackgroundsUnsplashPostRaw(requestParameters: ProjectsIdBackgroundsUnsplashPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProject>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdBackgroundsUnsplashPost().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsIdBackgroundsUnsplashPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/backgrounds/unsplash`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BackgroundImageToJSON(requestParameters['project']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectFromJSON(jsonValue));
    }

    /**
     * Sets a photo from unsplash as project background.
     * Set an unsplash photo as project background
     */
    async projectsIdBackgroundsUnsplashPost(requestParameters: ProjectsIdBackgroundsUnsplashPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProject> {
        const response = await this.projectsIdBackgroundsUnsplashPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a project background.
     * Upload a project background
     */
    async projectsIdBackgroundsUploadPutRaw(requestParameters: ProjectsIdBackgroundsUploadPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdBackgroundsUploadPut().'
            );
        }

        if (requestParameters['background'] == null) {
            throw new runtime.RequiredError(
                'background',
                'Required parameter "background" was null or undefined when calling projectsIdBackgroundsUploadPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['background'] != null) {
            formParams.append('background', requestParameters['background'] as any);
        }

        const response = await this.request({
            path: `/projects/{id}/backgrounds/upload`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Upload a project background.
     * Upload a project background
     */
    async projectsIdBackgroundsUploadPut(requestParameters: ProjectsIdBackgroundsUploadPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.projectsIdBackgroundsUploadPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delets a project
     * Deletes a project
     */
    async projectsIdDeleteRaw(requestParameters: ProjectsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Delets a project
     * Deletes a project
     */
    async projectsIdDelete(requestParameters: ProjectsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.projectsIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a project by its ID.
     * Gets one project
     */
    async projectsIdGetRaw(requestParameters: ProjectsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProject>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectFromJSON(jsonValue));
    }

    /**
     * Returns a project by its ID.
     * Gets one project
     */
    async projectsIdGet(requestParameters: ProjectsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProject> {
        const response = await this.projectsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a project. This does not include adding a task (see below).
     * Updates a project
     */
    async projectsIdPostRaw(requestParameters: ProjectsIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProject>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdPost().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsProjectToJSON(requestParameters['project']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectFromJSON(jsonValue));
    }

    /**
     * Updates a project. This does not include adding a task (see below).
     * Updates a project
     */
    async projectsIdPost(requestParameters: ProjectsIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProject> {
        const response = await this.projectsIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all users (without emailadresses). Also possible to search for a specific user.
     * Get users
     */
    async projectsIdProjectusersGetRaw(requestParameters: ProjectsIdProjectusersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserUser>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdProjectusersGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/projectusers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserUserFromJSON));
    }

    /**
     * Lists all users (without emailadresses). Also possible to search for a specific user.
     * Get users
     */
    async projectsIdProjectusersGet(requestParameters: ProjectsIdProjectusersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserUser>> {
        const response = await this.projectsIdProjectusersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all kanban buckets which belong to that project. Buckets are always sorted by their `position` in ascending order. To get all buckets with their tasks, use the tasks endpoint with a kanban view.
     * Get all kanban buckets of a project
     */
    async projectsIdViewsViewBucketsGetRaw(requestParameters: ProjectsIdViewsViewBucketsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsBucket>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdViewsViewBucketsGet().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling projectsIdViewsViewBucketsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/views/{view}/buckets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsBucketFromJSON));
    }

    /**
     * Returns all kanban buckets which belong to that project. Buckets are always sorted by their `position` in ascending order. To get all buckets with their tasks, use the tasks endpoint with a kanban view.
     * Get all kanban buckets of a project
     */
    async projectsIdViewsViewBucketsGet(requestParameters: ProjectsIdViewsViewBucketsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsBucket>> {
        const response = await this.projectsIdViewsViewBucketsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new kanban bucket on a project.
     * Create a new bucket
     */
    async projectsIdViewsViewBucketsPutRaw(requestParameters: ProjectsIdViewsViewBucketsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsBucket>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdViewsViewBucketsPut().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling projectsIdViewsViewBucketsPut().'
            );
        }

        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling projectsIdViewsViewBucketsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/views/{view}/buckets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsBucketToJSON(requestParameters['bucket']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsBucketFromJSON(jsonValue));
    }

    /**
     * Creates a new kanban bucket on a project.
     * Create a new bucket
     */
    async projectsIdViewsViewBucketsPut(requestParameters: ProjectsIdViewsViewBucketsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsBucket> {
        const response = await this.projectsIdViewsViewBucketsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Copies the project, tasks, files, kanban data, assignees, comments, attachments, lables, relations, backgrounds, user/team rights and link shares from one project to a new one. The user needs read access in the project and write access in the parent of the new project.
     * Duplicate an existing project
     */
    async projectsProjectIDDuplicatePutRaw(requestParameters: ProjectsProjectIDDuplicatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProjectDuplicate>> {
        if (requestParameters['projectID'] == null) {
            throw new runtime.RequiredError(
                'projectID',
                'Required parameter "projectID" was null or undefined when calling projectsProjectIDDuplicatePut().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsProjectIDDuplicatePut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{projectID}/duplicate`.replace(`{${"projectID"}}`, encodeURIComponent(String(requestParameters['projectID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsProjectDuplicateToJSON(requestParameters['project']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectDuplicateFromJSON(jsonValue));
    }

    /**
     * Copies the project, tasks, files, kanban data, assignees, comments, attachments, lables, relations, backgrounds, user/team rights and link shares from one project to a new one. The user needs read access in the project and write access in the parent of the new project.
     * Duplicate an existing project
     */
    async projectsProjectIDDuplicatePut(requestParameters: ProjectsProjectIDDuplicatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProjectDuplicate> {
        const response = await this.projectsProjectIDDuplicatePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes an existing kanban bucket and dissociates all of its task. It does not delete any tasks. You cannot delete the last bucket on a project.
     * Deletes an existing bucket
     */
    async projectsProjectIDViewsViewBucketsBucketIDDeleteRaw(requestParameters: ProjectsProjectIDViewsViewBucketsBucketIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['projectID'] == null) {
            throw new runtime.RequiredError(
                'projectID',
                'Required parameter "projectID" was null or undefined when calling projectsProjectIDViewsViewBucketsBucketIDDelete().'
            );
        }

        if (requestParameters['bucketID'] == null) {
            throw new runtime.RequiredError(
                'bucketID',
                'Required parameter "bucketID" was null or undefined when calling projectsProjectIDViewsViewBucketsBucketIDDelete().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling projectsProjectIDViewsViewBucketsBucketIDDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{projectID}/views/{view}/buckets/{bucketID}`.replace(`{${"projectID"}}`, encodeURIComponent(String(requestParameters['projectID']))).replace(`{${"bucketID"}}`, encodeURIComponent(String(requestParameters['bucketID']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Deletes an existing kanban bucket and dissociates all of its task. It does not delete any tasks. You cannot delete the last bucket on a project.
     * Deletes an existing bucket
     */
    async projectsProjectIDViewsViewBucketsBucketIDDelete(requestParameters: ProjectsProjectIDViewsViewBucketsBucketIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.projectsProjectIDViewsViewBucketsBucketIDDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing kanban bucket.
     * Update an existing bucket
     */
    async projectsProjectIDViewsViewBucketsBucketIDPostRaw(requestParameters: ProjectsProjectIDViewsViewBucketsBucketIDPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsBucket>> {
        if (requestParameters['projectID'] == null) {
            throw new runtime.RequiredError(
                'projectID',
                'Required parameter "projectID" was null or undefined when calling projectsProjectIDViewsViewBucketsBucketIDPost().'
            );
        }

        if (requestParameters['bucketID'] == null) {
            throw new runtime.RequiredError(
                'bucketID',
                'Required parameter "bucketID" was null or undefined when calling projectsProjectIDViewsViewBucketsBucketIDPost().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling projectsProjectIDViewsViewBucketsBucketIDPost().'
            );
        }

        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling projectsProjectIDViewsViewBucketsBucketIDPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{projectID}/views/{view}/buckets/{bucketID}`.replace(`{${"projectID"}}`, encodeURIComponent(String(requestParameters['projectID']))).replace(`{${"bucketID"}}`, encodeURIComponent(String(requestParameters['bucketID']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsBucketToJSON(requestParameters['bucket']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsBucketFromJSON(jsonValue));
    }

    /**
     * Updates an existing kanban bucket.
     * Update an existing bucket
     */
    async projectsProjectIDViewsViewBucketsBucketIDPost(requestParameters: ProjectsProjectIDViewsViewBucketsBucketIDPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsBucket> {
        const response = await this.projectsProjectIDViewsViewBucketsBucketIDPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all project views for a sepcific project
     * Get all project views for a project
     */
    async projectsProjectViewsGetRaw(requestParameters: ProjectsProjectViewsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsProjectView>>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsProjectViewsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{project}/views`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsProjectViewFromJSON));
    }

    /**
     * Returns all project views for a sepcific project
     * Get all project views for a project
     */
    async projectsProjectViewsGet(requestParameters: ProjectsProjectViewsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsProjectView>> {
        const response = await this.projectsProjectViewsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a project view.
     * Delete a project view
     */
    async projectsProjectViewsIdDeleteRaw(requestParameters: ProjectsProjectViewsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsProjectViewsIdDelete().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsProjectViewsIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{project}/views/{id}`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Deletes a project view.
     * Delete a project view
     */
    async projectsProjectViewsIdDelete(requestParameters: ProjectsProjectViewsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.projectsProjectViewsIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a project view by its ID.
     * Get one project view
     */
    async projectsProjectViewsIdGetRaw(requestParameters: ProjectsProjectViewsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProjectView>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsProjectViewsIdGet().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsProjectViewsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{project}/views/{id}`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectViewFromJSON(jsonValue));
    }

    /**
     * Returns a project view by its ID.
     * Get one project view
     */
    async projectsProjectViewsIdGet(requestParameters: ProjectsProjectViewsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProjectView> {
        const response = await this.projectsProjectViewsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a project view.
     * Updates a project view
     */
    async projectsProjectViewsIdPostRaw(requestParameters: ProjectsProjectViewsIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProjectView>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsProjectViewsIdPost().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsProjectViewsIdPost().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling projectsProjectViewsIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{project}/views/{id}`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsProjectViewToJSON(requestParameters['view']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectViewFromJSON(jsonValue));
    }

    /**
     * Updates a project view.
     * Updates a project view
     */
    async projectsProjectViewsIdPost(requestParameters: ProjectsProjectViewsIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProjectView> {
        const response = await this.projectsProjectViewsIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a project view in a specific project.
     * Create a project view
     */
    async projectsProjectViewsPutRaw(requestParameters: ProjectsProjectViewsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProjectView>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsProjectViewsPut().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling projectsProjectViewsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{project}/views`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsProjectViewToJSON(requestParameters['view']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectViewFromJSON(jsonValue));
    }

    /**
     * Create a project view in a specific project.
     * Create a project view
     */
    async projectsProjectViewsPut(requestParameters: ProjectsProjectViewsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProjectView> {
        const response = await this.projectsProjectViewsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new project. If a parent project is provided the user needs to have write access to that project.
     * Creates a new project
     */
    async projectsPutRaw(requestParameters: ProjectsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsProject>> {
        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling projectsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsProjectToJSON(requestParameters['project']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsProjectFromJSON(jsonValue));
    }

    /**
     * Creates a new project. If a parent project is provided the user needs to have write access to that project.
     * Creates a new project
     */
    async projectsPut(requestParameters: ProjectsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsProject> {
        const response = await this.projectsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
