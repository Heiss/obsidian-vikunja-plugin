/* tslint:disable */
/* eslint-disable */
/**
 * Vikunja API
 * # Pagination Every endpoint capable of pagination will return two headers: * `x-pagination-total-pages`: The total number of available pages for this request * `x-pagination-result-count`: The number of items returned for this request. # Rights All endpoints which return a single item (project, task, etc.) - no array - will also return a `x-max-right` header with the max right the user has on this item as an int where `0` is `Read Only`, `1` is `Read & Write` and `2` is `Admin`. This can be used to show or hide ui elements based on the rights the user has. # Errors All errors have an error code and a human-readable error message in addition to the http status code. You should always check for the status code in the response, not only the http status code. Due to limitations in the swagger library we\'re using for this document, only one error per http status code is documented here. Make sure to check the [error docs](https://vikunja.io/docs/errors/) in Vikunja\'s documentation for a full list of available error codes. # Authorization **JWT-Auth:** Main authorization method, used for most of the requests. Needs `Authorization: Bearer <jwt-token>`-header to authenticate successfully.  **API Token:** You can create scoped API tokens for your user and use the token to make authenticated requests in the context of that user. The token must be provided via an `Authorization: Bearer <token>` header, similar to jwt auth. See the documentation for the `api` group to manage token creation and revocation.  **BasicAuth:** Only used when requesting tasks via CalDAV. <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: v0.23.0-832-2d358a57cc
 * Contact: hello@vikunja.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ModelsLabel,
  ModelsLabelTask,
  ModelsLabelTaskBulk,
  ModelsMessage,
  WebHTTPError,
} from '../models/index';
import {
    ModelsLabelFromJSON,
    ModelsLabelToJSON,
    ModelsLabelTaskFromJSON,
    ModelsLabelTaskToJSON,
    ModelsLabelTaskBulkFromJSON,
    ModelsLabelTaskBulkToJSON,
    ModelsMessageFromJSON,
    ModelsMessageToJSON,
    WebHTTPErrorFromJSON,
    WebHTTPErrorToJSON,
} from '../models/index';

export interface LabelsGetRequest {
    page?: number;
    perPage?: number;
    s?: string;
}

export interface LabelsIdDeleteRequest {
    id: number;
}

export interface LabelsIdGetRequest {
    id: number;
}

export interface LabelsIdPutRequest {
    id: number;
    label: ModelsLabel;
}

export interface LabelsPutRequest {
    label: ModelsLabel;
}

export interface TasksTaskIDLabelsBulkPostRequest {
    taskID: number;
    label: ModelsLabelTaskBulk;
}

export interface TasksTaskLabelsGetRequest {
    task: number;
    page?: number;
    perPage?: number;
    s?: string;
}

export interface TasksTaskLabelsLabelDeleteRequest {
    task: number;
    label: number;
}

export interface TasksTaskLabelsPutRequest {
    task: number;
    label: ModelsLabelTask;
}

/**
 * 
 */
export class LabelsApi extends runtime.BaseAPI {

    /**
     * Returns all labels which are either created by the user or associated with a task the user has at least read-access to.
     * Get all labels a user has access to
     */
    async labelsGetRaw(requestParameters: LabelsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsLabel>>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/labels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsLabelFromJSON));
    }

    /**
     * Returns all labels which are either created by the user or associated with a task the user has at least read-access to.
     * Get all labels a user has access to
     */
    async labelsGet(requestParameters: LabelsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsLabel>> {
        const response = await this.labelsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an existing label. The user needs to be the creator of the label to be able to do this.
     * Delete a label
     */
    async labelsIdDeleteRaw(requestParameters: LabelsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsLabel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling labelsIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/labels/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsLabelFromJSON(jsonValue));
    }

    /**
     * Delete an existing label. The user needs to be the creator of the label to be able to do this.
     * Delete a label
     */
    async labelsIdDelete(requestParameters: LabelsIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsLabel> {
        const response = await this.labelsIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns one label by its ID.
     * Gets one label
     */
    async labelsIdGetRaw(requestParameters: LabelsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsLabel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling labelsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/labels/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsLabelFromJSON(jsonValue));
    }

    /**
     * Returns one label by its ID.
     * Gets one label
     */
    async labelsIdGet(requestParameters: LabelsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsLabel> {
        const response = await this.labelsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing label. The user needs to be the creator of the label to be able to do this.
     * Update a label
     */
    async labelsIdPutRaw(requestParameters: LabelsIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsLabel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling labelsIdPut().'
            );
        }

        if (requestParameters['label'] == null) {
            throw new runtime.RequiredError(
                'label',
                'Required parameter "label" was null or undefined when calling labelsIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/labels/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsLabelToJSON(requestParameters['label']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsLabelFromJSON(jsonValue));
    }

    /**
     * Update an existing label. The user needs to be the creator of the label to be able to do this.
     * Update a label
     */
    async labelsIdPut(requestParameters: LabelsIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsLabel> {
        const response = await this.labelsIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new label.
     * Create a label
     */
    async labelsPutRaw(requestParameters: LabelsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsLabel>> {
        if (requestParameters['label'] == null) {
            throw new runtime.RequiredError(
                'label',
                'Required parameter "label" was null or undefined when calling labelsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/labels`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsLabelToJSON(requestParameters['label']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsLabelFromJSON(jsonValue));
    }

    /**
     * Creates a new label.
     * Create a label
     */
    async labelsPut(requestParameters: LabelsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsLabel> {
        const response = await this.labelsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates all labels on a task. Every label which is not passed but exists on the task will be deleted. Every label which does not exist on the task will be added. All labels which are passed and already exist on the task won\'t be touched.
     * Update all labels on a task.
     */
    async tasksTaskIDLabelsBulkPostRaw(requestParameters: TasksTaskIDLabelsBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsLabelTaskBulk>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDLabelsBulkPost().'
            );
        }

        if (requestParameters['label'] == null) {
            throw new runtime.RequiredError(
                'label',
                'Required parameter "label" was null or undefined when calling tasksTaskIDLabelsBulkPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/labels/bulk`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsLabelTaskBulkToJSON(requestParameters['label']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsLabelTaskBulkFromJSON(jsonValue));
    }

    /**
     * Updates all labels on a task. Every label which is not passed but exists on the task will be deleted. Every label which does not exist on the task will be added. All labels which are passed and already exist on the task won\'t be touched.
     * Update all labels on a task.
     */
    async tasksTaskIDLabelsBulkPost(requestParameters: TasksTaskIDLabelsBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsLabelTaskBulk> {
        const response = await this.tasksTaskIDLabelsBulkPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all labels which are assicociated with a given task.
     * Get all labels on a task
     */
    async tasksTaskLabelsGetRaw(requestParameters: TasksTaskLabelsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsLabel>>> {
        if (requestParameters['task'] == null) {
            throw new runtime.RequiredError(
                'task',
                'Required parameter "task" was null or undefined when calling tasksTaskLabelsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{task}/labels`.replace(`{${"task"}}`, encodeURIComponent(String(requestParameters['task']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsLabelFromJSON));
    }

    /**
     * Returns all labels which are assicociated with a given task.
     * Get all labels on a task
     */
    async tasksTaskLabelsGet(requestParameters: TasksTaskLabelsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsLabel>> {
        const response = await this.tasksTaskLabelsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a label from a task. The user needs to have write-access to the project to be able do this.
     * Remove a label from a task
     */
    async tasksTaskLabelsLabelDeleteRaw(requestParameters: TasksTaskLabelsLabelDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['task'] == null) {
            throw new runtime.RequiredError(
                'task',
                'Required parameter "task" was null or undefined when calling tasksTaskLabelsLabelDelete().'
            );
        }

        if (requestParameters['label'] == null) {
            throw new runtime.RequiredError(
                'label',
                'Required parameter "label" was null or undefined when calling tasksTaskLabelsLabelDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{task}/labels/{label}`.replace(`{${"task"}}`, encodeURIComponent(String(requestParameters['task']))).replace(`{${"label"}}`, encodeURIComponent(String(requestParameters['label']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Remove a label from a task. The user needs to have write-access to the project to be able do this.
     * Remove a label from a task
     */
    async tasksTaskLabelsLabelDelete(requestParameters: TasksTaskLabelsLabelDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.tasksTaskLabelsLabelDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a label to a task. The user needs to have write-access to the project to be able do this.
     * Add a label to a task
     */
    async tasksTaskLabelsPutRaw(requestParameters: TasksTaskLabelsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsLabelTask>> {
        if (requestParameters['task'] == null) {
            throw new runtime.RequiredError(
                'task',
                'Required parameter "task" was null or undefined when calling tasksTaskLabelsPut().'
            );
        }

        if (requestParameters['label'] == null) {
            throw new runtime.RequiredError(
                'label',
                'Required parameter "label" was null or undefined when calling tasksTaskLabelsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{task}/labels`.replace(`{${"task"}}`, encodeURIComponent(String(requestParameters['task']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsLabelTaskToJSON(requestParameters['label']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsLabelTaskFromJSON(jsonValue));
    }

    /**
     * Add a label to a task. The user needs to have write-access to the project to be able do this.
     * Add a label to a task
     */
    async tasksTaskLabelsPut(requestParameters: TasksTaskLabelsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsLabelTask> {
        const response = await this.tasksTaskLabelsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
