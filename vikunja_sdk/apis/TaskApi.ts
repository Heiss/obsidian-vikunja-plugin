/* tslint:disable */
/* eslint-disable */
/**
 * Vikunja API
 * # Pagination Every endpoint capable of pagination will return two headers: * `x-pagination-total-pages`: The total number of available pages for this request * `x-pagination-result-count`: The number of items returned for this request. # Rights All endpoints which return a single item (project, task, etc.) - no array - will also return a `x-max-right` header with the max right the user has on this item as an int where `0` is `Read Only`, `1` is `Read & Write` and `2` is `Admin`. This can be used to show or hide ui elements based on the rights the user has. # Errors All errors have an error code and a human-readable error message in addition to the http status code. You should always check for the status code in the response, not only the http status code. Due to limitations in the swagger library we\'re using for this document, only one error per http status code is documented here. Make sure to check the [error docs](https://vikunja.io/docs/errors/) in Vikunja\'s documentation for a full list of available error codes. # Authorization **JWT-Auth:** Main authorization method, used for most of the requests. Needs `Authorization: Bearer <jwt-token>`-header to authenticate successfully.  **API Token:** You can create scoped API tokens for your user and use the token to make authenticated requests in the context of that user. The token must be provided via an `Authorization: Bearer <token>` header, similar to jwt auth. See the documentation for the `api` group to manage token creation and revocation.  **BasicAuth:** Only used when requesting tasks via CalDAV. <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: v0.23.0-879-f2ac9c2cca
 * Contact: hello@vikunja.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ModelsBulkTask,
  ModelsMessage,
  ModelsReaction,
  ModelsTask,
  ModelsTaskAttachment,
  ModelsTaskComment,
  ModelsTaskPosition,
  ModelsTaskRelation,
  UserUser,
  WebHTTPError,
} from '../models/index';
import {
    ModelsBulkTaskFromJSON,
    ModelsBulkTaskToJSON,
    ModelsMessageFromJSON,
    ModelsMessageToJSON,
    ModelsReactionFromJSON,
    ModelsReactionToJSON,
    ModelsTaskFromJSON,
    ModelsTaskToJSON,
    ModelsTaskAttachmentFromJSON,
    ModelsTaskAttachmentToJSON,
    ModelsTaskCommentFromJSON,
    ModelsTaskCommentToJSON,
    ModelsTaskPositionFromJSON,
    ModelsTaskPositionToJSON,
    ModelsTaskRelationFromJSON,
    ModelsTaskRelationToJSON,
    UserUserFromJSON,
    UserUserToJSON,
    WebHTTPErrorFromJSON,
    WebHTTPErrorToJSON,
} from '../models/index';

export interface KindIdReactionsDeletePostRequest {
    id: number;
    kind: number;
    project: ModelsReaction;
}

export interface KindIdReactionsGetRequest {
    id: number;
    kind: number;
}

export interface KindIdReactionsPutRequest {
    id: number;
    kind: number;
    project: ModelsReaction;
}

export interface ProjectsIdTasksPutRequest {
    id: number;
    task: ModelsTask;
}

export interface ProjectsIdViewsViewTasksGetRequest {
    id: number;
    view: number;
    page?: number;
    perPage?: number;
    s?: string;
    sortBy?: string;
    orderBy?: string;
    filter?: string;
    filterTimezone?: string;
    filterIncludeNulls?: string;
    expand?: string;
}

export interface TasksAllGetRequest {
    page?: number;
    perPage?: number;
    s?: string;
    sortBy?: string;
    orderBy?: string;
    filter?: string;
    filterTimezone?: string;
    filterIncludeNulls?: string;
    expand?: string;
}

export interface TasksBulkPostRequest {
    task: ModelsBulkTask;
}

export interface TasksIdAttachmentsAttachmentIDDeleteRequest {
    id: number;
    attachmentID: number;
}

export interface TasksIdAttachmentsAttachmentIDGetRequest {
    id: number;
    attachmentID: number;
}

export interface TasksIdAttachmentsGetRequest {
    id: number;
    page?: number;
    perPage?: number;
}

export interface TasksIdAttachmentsPutRequest {
    id: number;
    files: string;
}

export interface TasksIdDeleteRequest {
    id: number;
}

export interface TasksIdGetRequest {
    id: number;
}

export interface TasksIdPositionPostRequest {
    id: number;
    view: ModelsTaskPosition;
}

export interface TasksIdPostRequest {
    id: number;
    task: ModelsTask;
}

export interface TasksTaskIDCommentsCommentIDDeleteRequest {
    taskID: number;
    commentID: number;
}

export interface TasksTaskIDCommentsCommentIDGetRequest {
    taskID: number;
    commentID: number;
}

export interface TasksTaskIDCommentsCommentIDPostRequest {
    taskID: number;
    commentID: number;
}

export interface TasksTaskIDCommentsGetRequest {
    taskID: number;
}

export interface TasksTaskIDCommentsPutRequest {
    taskID: number;
    relation: ModelsTaskComment;
}

export interface TasksTaskIDRelationsPutRequest {
    taskID: number;
    relation: ModelsTaskRelation;
}

export interface TasksTaskIDRelationsRelationKindOtherTaskIDDeleteRequest {
    taskID: number;
    relationKind: string;
    otherTaskID: number;
    relation: ModelsTaskRelation;
}

/**
 * 
 */
export class TaskApi extends runtime.BaseAPI {

    /**
     * Removes the reaction of that user on that entity.
     * Removes the user\'s reaction
     */
    async kindIdReactionsDeletePostRaw(requestParameters: KindIdReactionsDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling kindIdReactionsDeletePost().'
            );
        }

        if (requestParameters['kind'] == null) {
            throw new runtime.RequiredError(
                'kind',
                'Required parameter "kind" was null or undefined when calling kindIdReactionsDeletePost().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling kindIdReactionsDeletePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/{kind}/{id}/reactions/delete`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"kind"}}`, encodeURIComponent(String(requestParameters['kind']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsReactionToJSON(requestParameters['project']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Removes the reaction of that user on that entity.
     * Removes the user\'s reaction
     */
    async kindIdReactionsDeletePost(requestParameters: KindIdReactionsDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.kindIdReactionsDeletePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all reactions for an entity
     * Get all reactions for an entity
     */
    async kindIdReactionsGetRaw(requestParameters: KindIdReactionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<{ [key: string]: Array<UserUser>; }>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling kindIdReactionsGet().'
            );
        }

        if (requestParameters['kind'] == null) {
            throw new runtime.RequiredError(
                'kind',
                'Required parameter "kind" was null or undefined when calling kindIdReactionsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/{kind}/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"kind"}}`, encodeURIComponent(String(requestParameters['kind']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns all reactions for an entity
     * Get all reactions for an entity
     */
    async kindIdReactionsGet(requestParameters: KindIdReactionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<{ [key: string]: Array<UserUser>; }>> {
        const response = await this.kindIdReactionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a reaction to an entity. Will do nothing if the reaction already exists.
     * Add a reaction to an entity
     */
    async kindIdReactionsPutRaw(requestParameters: KindIdReactionsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsReaction>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling kindIdReactionsPut().'
            );
        }

        if (requestParameters['kind'] == null) {
            throw new runtime.RequiredError(
                'kind',
                'Required parameter "kind" was null or undefined when calling kindIdReactionsPut().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling kindIdReactionsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/{kind}/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"kind"}}`, encodeURIComponent(String(requestParameters['kind']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsReactionToJSON(requestParameters['project']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsReactionFromJSON(jsonValue));
    }

    /**
     * Add a reaction to an entity. Will do nothing if the reaction already exists.
     * Add a reaction to an entity
     */
    async kindIdReactionsPut(requestParameters: KindIdReactionsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsReaction> {
        const response = await this.kindIdReactionsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts a task into a project.
     * Create a task
     */
    async projectsIdTasksPutRaw(requestParameters: ProjectsIdTasksPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTask>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdTasksPut().'
            );
        }

        if (requestParameters['task'] == null) {
            throw new runtime.RequiredError(
                'task',
                'Required parameter "task" was null or undefined when calling projectsIdTasksPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/tasks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsTaskToJSON(requestParameters['task']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskFromJSON(jsonValue));
    }

    /**
     * Inserts a task into a project.
     * Create a task
     */
    async projectsIdTasksPut(requestParameters: ProjectsIdTasksPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTask> {
        const response = await this.projectsIdTasksPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all tasks for the current project.
     * Get tasks in a project
     */
    async projectsIdViewsViewTasksGetRaw(requestParameters: ProjectsIdViewsViewTasksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsTask>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling projectsIdViewsViewTasksGet().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling projectsIdViewsViewTasksGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['order_by'] = requestParameters['orderBy'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['filterTimezone'] != null) {
            queryParameters['filter_timezone'] = requestParameters['filterTimezone'];
        }

        if (requestParameters['filterIncludeNulls'] != null) {
            queryParameters['filter_include_nulls'] = requestParameters['filterIncludeNulls'];
        }

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/projects/{id}/views/{view}/tasks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"view"}}`, encodeURIComponent(String(requestParameters['view']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsTaskFromJSON));
    }

    /**
     * Returns all tasks for the current project.
     * Get tasks in a project
     */
    async projectsIdViewsViewTasksGet(requestParameters: ProjectsIdViewsViewTasksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsTask>> {
        const response = await this.projectsIdViewsViewTasksGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all tasks on any project the user has access to.
     * Get tasks
     */
    async tasksAllGetRaw(requestParameters: TasksAllGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsTask>>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['order_by'] = requestParameters['orderBy'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['filterTimezone'] != null) {
            queryParameters['filter_timezone'] = requestParameters['filterTimezone'];
        }

        if (requestParameters['filterIncludeNulls'] != null) {
            queryParameters['filter_include_nulls'] = requestParameters['filterIncludeNulls'];
        }

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/all`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsTaskFromJSON));
    }

    /**
     * Returns all tasks on any project the user has access to.
     * Get tasks
     */
    async tasksAllGet(requestParameters: TasksAllGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsTask>> {
        const response = await this.tasksAllGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a bunch of tasks at once. This includes marking them as done. Note: although you could supply another ID, it will be ignored. Use task_ids instead.
     * Update a bunch of tasks at once
     */
    async tasksBulkPostRaw(requestParameters: TasksBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTask>> {
        if (requestParameters['task'] == null) {
            throw new runtime.RequiredError(
                'task',
                'Required parameter "task" was null or undefined when calling tasksBulkPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsBulkTaskToJSON(requestParameters['task']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskFromJSON(jsonValue));
    }

    /**
     * Updates a bunch of tasks at once. This includes marking them as done. Note: although you could supply another ID, it will be ignored. Use task_ids instead.
     * Update a bunch of tasks at once
     */
    async tasksBulkPost(requestParameters: TasksBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTask> {
        const response = await this.tasksBulkPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an attachment.
     * Delete an attachment
     */
    async tasksIdAttachmentsAttachmentIDDeleteRaw(requestParameters: TasksIdAttachmentsAttachmentIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdAttachmentsAttachmentIDDelete().'
            );
        }

        if (requestParameters['attachmentID'] == null) {
            throw new runtime.RequiredError(
                'attachmentID',
                'Required parameter "attachmentID" was null or undefined when calling tasksIdAttachmentsAttachmentIDDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{id}/attachments/{attachmentID}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"attachmentID"}}`, encodeURIComponent(String(requestParameters['attachmentID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Delete an attachment.
     * Delete an attachment
     */
    async tasksIdAttachmentsAttachmentIDDelete(requestParameters: TasksIdAttachmentsAttachmentIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.tasksIdAttachmentsAttachmentIDDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get one attachment for download. **Returns json on error.**
     * Get one attachment.
     */
    async tasksIdAttachmentsAttachmentIDGetRaw(requestParameters: TasksIdAttachmentsAttachmentIDGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdAttachmentsAttachmentIDGet().'
            );
        }

        if (requestParameters['attachmentID'] == null) {
            throw new runtime.RequiredError(
                'attachmentID',
                'Required parameter "attachmentID" was null or undefined when calling tasksIdAttachmentsAttachmentIDGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{id}/attachments/{attachmentID}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"attachmentID"}}`, encodeURIComponent(String(requestParameters['attachmentID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get one attachment for download. **Returns json on error.**
     * Get one attachment.
     */
    async tasksIdAttachmentsAttachmentIDGet(requestParameters: TasksIdAttachmentsAttachmentIDGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.tasksIdAttachmentsAttachmentIDGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all task attachments for one task.
     * Get  all attachments for one task.
     */
    async tasksIdAttachmentsGetRaw(requestParameters: TasksIdAttachmentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsTaskAttachment>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdAttachmentsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{id}/attachments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsTaskAttachmentFromJSON));
    }

    /**
     * Get all task attachments for one task.
     * Get  all attachments for one task.
     */
    async tasksIdAttachmentsGet(requestParameters: TasksIdAttachmentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsTaskAttachment>> {
        const response = await this.tasksIdAttachmentsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a task attachment. You can pass multiple files with the files form param.
     * Upload a task attachment
     */
    async tasksIdAttachmentsPutRaw(requestParameters: TasksIdAttachmentsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdAttachmentsPut().'
            );
        }

        if (requestParameters['files'] == null) {
            throw new runtime.RequiredError(
                'files',
                'Required parameter "files" was null or undefined when calling tasksIdAttachmentsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['files'] != null) {
            formParams.append('files', requestParameters['files'] as any);
        }

        const response = await this.request({
            path: `/tasks/{id}/attachments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Upload a task attachment. You can pass multiple files with the files form param.
     * Upload a task attachment
     */
    async tasksIdAttachmentsPut(requestParameters: TasksIdAttachmentsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.tasksIdAttachmentsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a task from a project. This does not mean \"mark it done\".
     * Delete a task
     */
    async tasksIdDeleteRaw(requestParameters: TasksIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Deletes a task from a project. This does not mean \"mark it done\".
     * Delete a task
     */
    async tasksIdDelete(requestParameters: TasksIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.tasksIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns one task by its ID
     * Get one task
     */
    async tasksIdGetRaw(requestParameters: TasksIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTask>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskFromJSON(jsonValue));
    }

    /**
     * Returns one task by its ID
     * Get one task
     */
    async tasksIdGet(requestParameters: TasksIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTask> {
        const response = await this.tasksIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a task position.
     * Updates a task position
     */
    async tasksIdPositionPostRaw(requestParameters: TasksIdPositionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTaskPosition>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdPositionPost().'
            );
        }

        if (requestParameters['view'] == null) {
            throw new runtime.RequiredError(
                'view',
                'Required parameter "view" was null or undefined when calling tasksIdPositionPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{id}/position`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsTaskPositionToJSON(requestParameters['view']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskPositionFromJSON(jsonValue));
    }

    /**
     * Updates a task position.
     * Updates a task position
     */
    async tasksIdPositionPost(requestParameters: TasksIdPositionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTaskPosition> {
        const response = await this.tasksIdPositionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a task. This includes marking it as done. Assignees you pass will be updated, see their individual endpoints for more details on how this is done. To update labels, see the description of the endpoint.
     * Update a task
     */
    async tasksIdPostRaw(requestParameters: TasksIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTask>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling tasksIdPost().'
            );
        }

        if (requestParameters['task'] == null) {
            throw new runtime.RequiredError(
                'task',
                'Required parameter "task" was null or undefined when calling tasksIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsTaskToJSON(requestParameters['task']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskFromJSON(jsonValue));
    }

    /**
     * Updates a task. This includes marking it as done. Assignees you pass will be updated, see their individual endpoints for more details on how this is done. To update labels, see the description of the endpoint.
     * Update a task
     */
    async tasksIdPost(requestParameters: TasksIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTask> {
        const response = await this.tasksIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a task comment. The user doing this need to have at least write access to the task this comment belongs to.
     * Remove a task comment
     */
    async tasksTaskIDCommentsCommentIDDeleteRaw(requestParameters: TasksTaskIDCommentsCommentIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDCommentsCommentIDDelete().'
            );
        }

        if (requestParameters['commentID'] == null) {
            throw new runtime.RequiredError(
                'commentID',
                'Required parameter "commentID" was null or undefined when calling tasksTaskIDCommentsCommentIDDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/comments/{commentID}`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))).replace(`{${"commentID"}}`, encodeURIComponent(String(requestParameters['commentID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Remove a task comment. The user doing this need to have at least write access to the task this comment belongs to.
     * Remove a task comment
     */
    async tasksTaskIDCommentsCommentIDDelete(requestParameters: TasksTaskIDCommentsCommentIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.tasksTaskIDCommentsCommentIDDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a task comment. The user doing this need to have at least read access to the task this comment belongs to.
     * Remove a task comment
     */
    async tasksTaskIDCommentsCommentIDGetRaw(requestParameters: TasksTaskIDCommentsCommentIDGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTaskComment>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDCommentsCommentIDGet().'
            );
        }

        if (requestParameters['commentID'] == null) {
            throw new runtime.RequiredError(
                'commentID',
                'Required parameter "commentID" was null or undefined when calling tasksTaskIDCommentsCommentIDGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/comments/{commentID}`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))).replace(`{${"commentID"}}`, encodeURIComponent(String(requestParameters['commentID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskCommentFromJSON(jsonValue));
    }

    /**
     * Remove a task comment. The user doing this need to have at least read access to the task this comment belongs to.
     * Remove a task comment
     */
    async tasksTaskIDCommentsCommentIDGet(requestParameters: TasksTaskIDCommentsCommentIDGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTaskComment> {
        const response = await this.tasksTaskIDCommentsCommentIDGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing task comment. The user doing this need to have at least write access to the task this comment belongs to.
     * Update an existing task comment
     */
    async tasksTaskIDCommentsCommentIDPostRaw(requestParameters: TasksTaskIDCommentsCommentIDPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTaskComment>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDCommentsCommentIDPost().'
            );
        }

        if (requestParameters['commentID'] == null) {
            throw new runtime.RequiredError(
                'commentID',
                'Required parameter "commentID" was null or undefined when calling tasksTaskIDCommentsCommentIDPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/comments/{commentID}`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))).replace(`{${"commentID"}}`, encodeURIComponent(String(requestParameters['commentID']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskCommentFromJSON(jsonValue));
    }

    /**
     * Update an existing task comment. The user doing this need to have at least write access to the task this comment belongs to.
     * Update an existing task comment
     */
    async tasksTaskIDCommentsCommentIDPost(requestParameters: TasksTaskIDCommentsCommentIDPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTaskComment> {
        const response = await this.tasksTaskIDCommentsCommentIDPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all task comments. The user doing this need to have at least read access to the task.
     * Get all task comments
     */
    async tasksTaskIDCommentsGetRaw(requestParameters: TasksTaskIDCommentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ModelsTaskComment>>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDCommentsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/comments`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelsTaskCommentFromJSON));
    }

    /**
     * Get all task comments. The user doing this need to have at least read access to the task.
     * Get all task comments
     */
    async tasksTaskIDCommentsGet(requestParameters: TasksTaskIDCommentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ModelsTaskComment>> {
        const response = await this.tasksTaskIDCommentsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new task comment. The user doing this need to have at least write access to the task this comment should belong to.
     * Create a new task comment
     */
    async tasksTaskIDCommentsPutRaw(requestParameters: TasksTaskIDCommentsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTaskComment>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDCommentsPut().'
            );
        }

        if (requestParameters['relation'] == null) {
            throw new runtime.RequiredError(
                'relation',
                'Required parameter "relation" was null or undefined when calling tasksTaskIDCommentsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/comments`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsTaskCommentToJSON(requestParameters['relation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskCommentFromJSON(jsonValue));
    }

    /**
     * Create a new task comment. The user doing this need to have at least write access to the task this comment should belong to.
     * Create a new task comment
     */
    async tasksTaskIDCommentsPut(requestParameters: TasksTaskIDCommentsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTaskComment> {
        const response = await this.tasksTaskIDCommentsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new relation between two tasks. The user needs to have update rights on the base task and at least read rights on the other task. Both tasks do not need to be on the same project. Take a look at the docs for available task relation kinds.
     * Create a new relation between two tasks
     */
    async tasksTaskIDRelationsPutRaw(requestParameters: TasksTaskIDRelationsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsTaskRelation>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDRelationsPut().'
            );
        }

        if (requestParameters['relation'] == null) {
            throw new runtime.RequiredError(
                'relation',
                'Required parameter "relation" was null or undefined when calling tasksTaskIDRelationsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/relations`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsTaskRelationToJSON(requestParameters['relation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsTaskRelationFromJSON(jsonValue));
    }

    /**
     * Creates a new relation between two tasks. The user needs to have update rights on the base task and at least read rights on the other task. Both tasks do not need to be on the same project. Take a look at the docs for available task relation kinds.
     * Create a new relation between two tasks
     */
    async tasksTaskIDRelationsPut(requestParameters: TasksTaskIDRelationsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsTaskRelation> {
        const response = await this.tasksTaskIDRelationsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a task relation
     */
    async tasksTaskIDRelationsRelationKindOtherTaskIDDeleteRaw(requestParameters: TasksTaskIDRelationsRelationKindOtherTaskIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['taskID'] == null) {
            throw new runtime.RequiredError(
                'taskID',
                'Required parameter "taskID" was null or undefined when calling tasksTaskIDRelationsRelationKindOtherTaskIDDelete().'
            );
        }

        if (requestParameters['relationKind'] == null) {
            throw new runtime.RequiredError(
                'relationKind',
                'Required parameter "relationKind" was null or undefined when calling tasksTaskIDRelationsRelationKindOtherTaskIDDelete().'
            );
        }

        if (requestParameters['otherTaskID'] == null) {
            throw new runtime.RequiredError(
                'otherTaskID',
                'Required parameter "otherTaskID" was null or undefined when calling tasksTaskIDRelationsRelationKindOtherTaskIDDelete().'
            );
        }

        if (requestParameters['relation'] == null) {
            throw new runtime.RequiredError(
                'relation',
                'Required parameter "relation" was null or undefined when calling tasksTaskIDRelationsRelationKindOtherTaskIDDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/tasks/{taskID}/relations/{relationKind}/{otherTaskID}`.replace(`{${"taskID"}}`, encodeURIComponent(String(requestParameters['taskID']))).replace(`{${"relationKind"}}`, encodeURIComponent(String(requestParameters['relationKind']))).replace(`{${"otherTaskID"}}`, encodeURIComponent(String(requestParameters['otherTaskID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: ModelsTaskRelationToJSON(requestParameters['relation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Remove a task relation
     */
    async tasksTaskIDRelationsRelationKindOtherTaskIDDelete(requestParameters: TasksTaskIDRelationsRelationKindOtherTaskIDDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.tasksTaskIDRelationsRelationKindOtherTaskIDDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
