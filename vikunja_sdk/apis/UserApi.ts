/* tslint:disable */
/* eslint-disable */
/**
 * Vikunja API
 * # Pagination Every endpoint capable of pagination will return two headers: * `x-pagination-total-pages`: The total number of available pages for this request * `x-pagination-result-count`: The number of items returned for this request. # Rights All endpoints which return a single item (project, task, etc.) - no array - will also return a `x-max-right` header with the max right the user has on this item as an int where `0` is `Read Only`, `1` is `Read & Write` and `2` is `Admin`. This can be used to show or hide ui elements based on the rights the user has. # Errors All errors have an error code and a human-readable error message in addition to the http status code. You should always check for the status code in the response, not only the http status code. Due to limitations in the swagger library we\'re using for this document, only one error per http status code is documented here. Make sure to check the [error docs](https://vikunja.io/docs/errors/) in Vikunja\'s documentation for a full list of available error codes. # Authorization **JWT-Auth:** Main authorization method, used for most of the requests. Needs `Authorization: Bearer <jwt-token>`-header to authenticate successfully.  **API Token:** You can create scoped API tokens for your user and use the token to make authenticated requests in the context of that user. The token must be provided via an `Authorization: Bearer <token>` header, similar to jwt auth. See the documentation for the `api` group to manage token creation and revocation.  **BasicAuth:** Only used when requesting tasks via CalDAV. <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: v0.23.0-832-2d358a57cc
 * Contact: hello@vikunja.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthToken,
  ModelsMessage,
  UserEmailConfirm,
  UserEmailUpdate,
  UserLogin,
  UserPasswordReset,
  UserPasswordTokenRequest,
  UserTOTP,
  UserTOTPPasscode,
  UserToken,
  UserUser,
  V1UserAvatarProvider,
  V1UserDeletionRequestConfirm,
  V1UserPassword,
  V1UserPasswordConfirmation,
  V1UserSettings,
  WebHTTPError,
} from '../models/index';
import {
    AuthTokenFromJSON,
    AuthTokenToJSON,
    ModelsMessageFromJSON,
    ModelsMessageToJSON,
    UserEmailConfirmFromJSON,
    UserEmailConfirmToJSON,
    UserEmailUpdateFromJSON,
    UserEmailUpdateToJSON,
    UserLoginFromJSON,
    UserLoginToJSON,
    UserPasswordResetFromJSON,
    UserPasswordResetToJSON,
    UserPasswordTokenRequestFromJSON,
    UserPasswordTokenRequestToJSON,
    UserTOTPFromJSON,
    UserTOTPToJSON,
    UserTOTPPasscodeFromJSON,
    UserTOTPPasscodeToJSON,
    UserTokenFromJSON,
    UserTokenToJSON,
    UserUserFromJSON,
    UserUserToJSON,
    V1UserAvatarProviderFromJSON,
    V1UserAvatarProviderToJSON,
    V1UserDeletionRequestConfirmFromJSON,
    V1UserDeletionRequestConfirmToJSON,
    V1UserPasswordFromJSON,
    V1UserPasswordToJSON,
    V1UserPasswordConfirmationFromJSON,
    V1UserPasswordConfirmationToJSON,
    V1UserSettingsFromJSON,
    V1UserSettingsToJSON,
    WebHTTPErrorFromJSON,
    WebHTTPErrorToJSON,
} from '../models/index';

export interface UserConfirmPostRequest {
    credentials: UserEmailConfirm;
}

export interface UserDeletionCancelPostRequest {
    credentials: V1UserPasswordConfirmation;
}

export interface UserDeletionConfirmPostRequest {
    credentials: V1UserDeletionRequestConfirm;
}

export interface UserDeletionRequestPostRequest {
    credentials: V1UserPasswordConfirmation;
}

export interface UserExportDownloadPostRequest {
    password: V1UserPasswordConfirmation;
}

export interface UserExportRequestPostRequest {
    password: V1UserPasswordConfirmation;
}

export interface UserPasswordPostRequest {
    userPassword: V1UserPassword;
}

export interface UserPasswordResetPostRequest {
    credentials: UserPasswordReset;
}

export interface UserPasswordTokenPostRequest {
    credentials: UserPasswordTokenRequest;
}

export interface UserSettingsAvatarPostRequest {
    avatar: V1UserAvatarProvider;
}

export interface UserSettingsAvatarUploadPutRequest {
    avatar: string;
}

export interface UserSettingsEmailPostRequest {
    userEmailUpdate: UserEmailUpdate;
}

export interface UserSettingsGeneralPostRequest {
    avatar: V1UserSettings;
}

export interface UserSettingsTokenCaldavIdGetRequest {
    id: number;
}

export interface UserSettingsTotpDisablePostRequest {
    totp: UserLogin;
}

export interface UserSettingsTotpEnablePostRequest {
    totp: UserTOTPPasscode;
}

export interface UsernameAvatarGetRequest {
    username: string;
    size?: number;
}

export interface UsersGetRequest {
    s?: string;
}

/**
 * 
 */
export class UserApi extends runtime.BaseAPI {

    /**
     * Confirms the email of a newly registered user.
     * Confirm the email of a new user
     */
    async userConfirmPostRaw(requestParameters: UserConfirmPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['credentials'] == null) {
            throw new runtime.RequiredError(
                'credentials',
                'Required parameter "credentials" was null or undefined when calling userConfirmPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/user/confirm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserEmailConfirmToJSON(requestParameters['credentials']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Confirms the email of a newly registered user.
     * Confirm the email of a new user
     */
    async userConfirmPost(requestParameters: UserConfirmPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userConfirmPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Aborts an in-progress user deletion.
     * Abort a user deletion request
     */
    async userDeletionCancelPostRaw(requestParameters: UserDeletionCancelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['credentials'] == null) {
            throw new runtime.RequiredError(
                'credentials',
                'Required parameter "credentials" was null or undefined when calling userDeletionCancelPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/user/deletion/cancel`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserPasswordConfirmationToJSON(requestParameters['credentials']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Aborts an in-progress user deletion.
     * Abort a user deletion request
     */
    async userDeletionCancelPost(requestParameters: UserDeletionCancelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userDeletionCancelPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Confirms the deletion request of a user sent via email.
     * Confirm a user deletion request
     */
    async userDeletionConfirmPostRaw(requestParameters: UserDeletionConfirmPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['credentials'] == null) {
            throw new runtime.RequiredError(
                'credentials',
                'Required parameter "credentials" was null or undefined when calling userDeletionConfirmPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/user/deletion/confirm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserDeletionRequestConfirmToJSON(requestParameters['credentials']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Confirms the deletion request of a user sent via email.
     * Confirm a user deletion request
     */
    async userDeletionConfirmPost(requestParameters: UserDeletionConfirmPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userDeletionConfirmPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Requests the deletion of the current user. It will trigger an email which has to be confirmed to start the deletion.
     * Request the deletion of the user
     */
    async userDeletionRequestPostRaw(requestParameters: UserDeletionRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['credentials'] == null) {
            throw new runtime.RequiredError(
                'credentials',
                'Required parameter "credentials" was null or undefined when calling userDeletionRequestPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/user/deletion/request`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserPasswordConfirmationToJSON(requestParameters['credentials']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Requests the deletion of the current user. It will trigger an email which has to be confirmed to start the deletion.
     * Request the deletion of the user
     */
    async userDeletionRequestPost(requestParameters: UserDeletionRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userDeletionRequestPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a user data export.
     */
    async userExportDownloadPostRaw(requestParameters: UserExportDownloadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['password'] == null) {
            throw new runtime.RequiredError(
                'password',
                'Required parameter "password" was null or undefined when calling userExportDownloadPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/export/download`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserPasswordConfirmationToJSON(requestParameters['password']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Download a user data export.
     */
    async userExportDownloadPost(requestParameters: UserExportDownloadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userExportDownloadPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request a user data export.
     */
    async userExportRequestPostRaw(requestParameters: UserExportRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['password'] == null) {
            throw new runtime.RequiredError(
                'password',
                'Required parameter "password" was null or undefined when calling userExportRequestPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/export/request`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserPasswordConfirmationToJSON(requestParameters['password']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Request a user data export.
     */
    async userExportRequestPost(requestParameters: UserExportRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userExportRequestPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current user object.
     * Get user information
     */
    async userGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserUser>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserUserFromJSON(jsonValue));
    }

    /**
     * Returns the current user object.
     * Get user information
     */
    async userGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserUser> {
        const response = await this.userGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lets the current user change its password.
     * Change password
     */
    async userPasswordPostRaw(requestParameters: UserPasswordPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['userPassword'] == null) {
            throw new runtime.RequiredError(
                'userPassword',
                'Required parameter "userPassword" was null or undefined when calling userPasswordPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/password`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserPasswordToJSON(requestParameters['userPassword']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Lets the current user change its password.
     * Change password
     */
    async userPasswordPost(requestParameters: UserPasswordPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userPasswordPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resets a user email with a previously reset token.
     * Resets a password
     */
    async userPasswordResetPostRaw(requestParameters: UserPasswordResetPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['credentials'] == null) {
            throw new runtime.RequiredError(
                'credentials',
                'Required parameter "credentials" was null or undefined when calling userPasswordResetPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/user/password/reset`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserPasswordResetToJSON(requestParameters['credentials']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Resets a user email with a previously reset token.
     * Resets a password
     */
    async userPasswordResetPost(requestParameters: UserPasswordResetPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userPasswordResetPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Requests a token to reset a users password. The token is sent via email.
     * Request password reset token
     */
    async userPasswordTokenPostRaw(requestParameters: UserPasswordTokenPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['credentials'] == null) {
            throw new runtime.RequiredError(
                'credentials',
                'Required parameter "credentials" was null or undefined when calling userPasswordTokenPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/user/password/token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserPasswordTokenRequestToJSON(requestParameters['credentials']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Requests a token to reset a users password. The token is sent via email.
     * Request password reset token
     */
    async userPasswordTokenPost(requestParameters: UserPasswordTokenPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userPasswordTokenPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current user\'s avatar setting.
     * Return user avatar setting
     */
    async userSettingsAvatarGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1UserAvatarProvider>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/avatar`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1UserAvatarProviderFromJSON(jsonValue));
    }

    /**
     * Returns the current user\'s avatar setting.
     * Return user avatar setting
     */
    async userSettingsAvatarGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1UserAvatarProvider> {
        const response = await this.userSettingsAvatarGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Changes the user avatar. Valid types are gravatar (uses the user email), upload, initials, default.
     * Set the user\'s avatar
     */
    async userSettingsAvatarPostRaw(requestParameters: UserSettingsAvatarPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['avatar'] == null) {
            throw new runtime.RequiredError(
                'avatar',
                'Required parameter "avatar" was null or undefined when calling userSettingsAvatarPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/avatar`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserAvatarProviderToJSON(requestParameters['avatar']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Changes the user avatar. Valid types are gravatar (uses the user email), upload, initials, default.
     * Set the user\'s avatar
     */
    async userSettingsAvatarPost(requestParameters: UserSettingsAvatarPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userSettingsAvatarPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a user avatar. This will also set the user\'s avatar provider to \"upload\"
     * Upload a user avatar
     */
    async userSettingsAvatarUploadPutRaw(requestParameters: UserSettingsAvatarUploadPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['avatar'] == null) {
            throw new runtime.RequiredError(
                'avatar',
                'Required parameter "avatar" was null or undefined when calling userSettingsAvatarUploadPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['avatar'] != null) {
            formParams.append('avatar', requestParameters['avatar'] as any);
        }

        const response = await this.request({
            path: `/user/settings/avatar/upload`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Upload a user avatar. This will also set the user\'s avatar provider to \"upload\"
     * Upload a user avatar
     */
    async userSettingsAvatarUploadPut(requestParameters: UserSettingsAvatarUploadPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userSettingsAvatarUploadPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lets the current user change their email address.
     * Update email address
     */
    async userSettingsEmailPostRaw(requestParameters: UserSettingsEmailPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['userEmailUpdate'] == null) {
            throw new runtime.RequiredError(
                'userEmailUpdate',
                'Required parameter "userEmailUpdate" was null or undefined when calling userSettingsEmailPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/email`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserEmailUpdateToJSON(requestParameters['userEmailUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Lets the current user change their email address.
     * Update email address
     */
    async userSettingsEmailPost(requestParameters: UserSettingsEmailPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userSettingsEmailPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Change general user settings of the current user.
     */
    async userSettingsGeneralPostRaw(requestParameters: UserSettingsGeneralPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['avatar'] == null) {
            throw new runtime.RequiredError(
                'avatar',
                'Required parameter "avatar" was null or undefined when calling userSettingsGeneralPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/general`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1UserSettingsToJSON(requestParameters['avatar']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Change general user settings of the current user.
     */
    async userSettingsGeneralPost(requestParameters: UserSettingsGeneralPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userSettingsGeneralPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the IDs and created dates of all caldav tokens for the current user.
     * Returns the caldav tokens for the current user
     */
    async userSettingsTokenCaldavGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserToken>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/token/caldav`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserTokenFromJSON));
    }

    /**
     * Return the IDs and created dates of all caldav tokens for the current user.
     * Returns the caldav tokens for the current user
     */
    async userSettingsTokenCaldavGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserToken>> {
        const response = await this.userSettingsTokenCaldavGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Delete a caldav token by id
     */
    async userSettingsTokenCaldavIdGetRaw(requestParameters: UserSettingsTokenCaldavIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling userSettingsTokenCaldavIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/token/caldav/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Delete a caldav token by id
     */
    async userSettingsTokenCaldavIdGet(requestParameters: UserSettingsTokenCaldavIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userSettingsTokenCaldavIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates a caldav token which can be used for the caldav api. It is not possible to see the token again after it was generated.
     * Generate a caldav token
     */
    async userSettingsTokenCaldavPutRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserToken>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/token/caldav`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserTokenFromJSON(jsonValue));
    }

    /**
     * Generates a caldav token which can be used for the caldav api. It is not possible to see the token again after it was generated.
     * Generate a caldav token
     */
    async userSettingsTokenCaldavPut(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserToken> {
        const response = await this.userSettingsTokenCaldavPutRaw(initOverrides);
        return await response.value();
    }

    /**
     * Disables any totp settings for the current user.
     * Disable totp settings
     */
    async userSettingsTotpDisablePostRaw(requestParameters: UserSettingsTotpDisablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['totp'] == null) {
            throw new runtime.RequiredError(
                'totp',
                'Required parameter "totp" was null or undefined when calling userSettingsTotpDisablePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/totp/disable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserLoginToJSON(requestParameters['totp']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Disables any totp settings for the current user.
     * Disable totp settings
     */
    async userSettingsTotpDisablePost(requestParameters: UserSettingsTotpDisablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userSettingsTotpDisablePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enables a previously enrolled totp setting by providing a totp passcode.
     * Enable a previously enrolled totp setting.
     */
    async userSettingsTotpEnablePostRaw(requestParameters: UserSettingsTotpEnablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelsMessage>> {
        if (requestParameters['totp'] == null) {
            throw new runtime.RequiredError(
                'totp',
                'Required parameter "totp" was null or undefined when calling userSettingsTotpEnablePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/totp/enable`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserTOTPPasscodeToJSON(requestParameters['totp']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelsMessageFromJSON(jsonValue));
    }

    /**
     * Enables a previously enrolled totp setting by providing a totp passcode.
     * Enable a previously enrolled totp setting.
     */
    async userSettingsTotpEnablePost(requestParameters: UserSettingsTotpEnablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelsMessage> {
        const response = await this.userSettingsTotpEnablePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an initial setup for the user in the db. After this step, the user needs to verify they have a working totp setup with the \"enable totp\" endpoint.
     * Enroll a user into totp
     */
    async userSettingsTotpEnrollPostRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserTOTP>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/totp/enroll`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserTOTPFromJSON(jsonValue));
    }

    /**
     * Creates an initial setup for the user in the db. After this step, the user needs to verify they have a working totp setup with the \"enable totp\" endpoint.
     * Enroll a user into totp
     */
    async userSettingsTotpEnrollPost(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserTOTP> {
        const response = await this.userSettingsTotpEnrollPostRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the current user totp setting or an error if it is not enabled.
     * Totp setting for the current user
     */
    async userSettingsTotpGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserTOTP>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/totp`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserTOTPFromJSON(jsonValue));
    }

    /**
     * Returns the current user totp setting or an error if it is not enabled.
     * Totp setting for the current user
     */
    async userSettingsTotpGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserTOTP> {
        const response = await this.userSettingsTotpGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a qr code for easier setup at end user\'s devices.
     * Totp QR Code
     */
    async userSettingsTotpQrcodeGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/settings/totp/qrcode`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Returns a qr code for easier setup at end user\'s devices.
     * Totp QR Code
     */
    async userSettingsTotpQrcodeGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.userSettingsTotpQrcodeGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Because available time zones depend on the system Vikunja is running on, this endpoint returns a project of all valid time zones this particular Vikunja instance can handle. The project of time zones is not sorted, you should sort it on the client.
     * Get all available time zones on this vikunja instance
     */
    async userTimezonesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/user/timezones`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Because available time zones depend on the system Vikunja is running on, this endpoint returns a project of all valid time zones this particular Vikunja instance can handle. The project of time zones is not sorted, you should sort it on the client.
     * Get all available time zones on this vikunja instance
     */
    async userTimezonesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.userTimezonesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a new valid jwt user token with an extended length.
     * Renew user token
     */
    async userTokenPostRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthToken>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user/token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthTokenFromJSON(jsonValue));
    }

    /**
     * Returns a new valid jwt user token with an extended length.
     * Renew user token
     */
    async userTokenPost(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthToken> {
        const response = await this.userTokenPostRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the user avatar as image.
     * User Avatar
     */
    async usernameAvatarGetRaw(requestParameters: UsernameAvatarGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling usernameAvatarGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{username}/avatar`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Returns the user avatar as image.
     * User Avatar
     */
    async usernameAvatarGet(requestParameters: UsernameAvatarGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.usernameAvatarGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for a user by its username, name or full email. Name (not username) or email require that the user has enabled this in their settings.
     * Get users
     */
    async usersGetRaw(requestParameters: UsersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserUser>>> {
        const queryParameters: any = {};

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // JWTKeyAuth authentication
        }

        const response = await this.request({
            path: `/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserUserFromJSON));
    }

    /**
     * Search for a user by its username, name or full email. Name (not username) or email require that the user has enabled this in their settings.
     * Get users
     */
    async usersGet(requestParameters: UsersGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserUser>> {
        const response = await this.usersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
